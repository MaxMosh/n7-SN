options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
opts_knit$set(width=75)
library(corrplot)
library(tidyverse)
library(gridExtra)
library(reshape2)
Data = read.table("wine.txt",header=TRUE)
head(Data)
attributes(Data)
str(Data)
Data$Qualite=as.factor(Data$Qualite)
Data$Type=factor(Data$Type,labels=c("blanc","rouge"))
head(Data)
summary(Data)
levels(Data$Type)
summary(Data$Type)
EffType = as.vector(table(Data$Type))
EffType
Freq = EffType/length(Data$Type)
knitr::kable(data.frame(modalite=levels(Data$Type),Eff=EffType,Freq=Freq), caption = 'Description de la variable Type',booktabs = TRUE,digits=3)
EffQual=as.vector(table(Data$Qualite))
FreqQual= data.frame(Eff = EffQual, Freq = EffQual/length(Data$Qualite), FreqCumul=cumsum(EffQual)/length(Data$Qualite))
rownames(FreqQual)=levels(Data$Qualite)
knitr::kable(FreqQual, caption = 'Description de la variable Qualite',booktabs = TRUE,digits=3)
g1<-ggplot(Data, aes(x=Type))+ geom_bar()+ylab("")+ggtitle("Effectifs")
g2<-ggplot(Data, aes(x = Type)) +
geom_bar(aes(y = (..count..)/sum(..count..)))+ylab("")+ggtitle("Frequences")
quan <- as.vector(table(Data$Type))/nrow(Data)
df <- data.frame(group = levels(Data$Type),value = quan)
g3<-ggplot(df, aes(x="", y=value, fill=group))+
geom_bar(width = 1, stat = "identity")+ coord_polar("y", start=0)+ theme(legend.position="bottom")
grid.arrange(g3,g1,g2,ncol=3)
Qualite_rec <- fct_relevel(Data$Qualite, "bad", "medium", "good")
df <- data.frame(Qualite = levels(Qualite_rec), value = table(Qualite_rec),
valuecumul = 100 * cumsum(prop.table(table(Qualite_rec))))
df$Qualite <- fct_relevel(df$Qualite, "bad", "medium", "good")
df <- df %>%
mutate(freq = value.Freq/nrow(Data))
g1 <- ggplot(Data) + geom_bar(aes(x = Qualite_rec)) + ggtitle("Effectifs")+xlab("Qualite")
g2 <- ggplot(Data) + geom_bar(aes(x = Qualite_rec, y = ..prop.., group = 1)) + ggtitle("Frequences")+xlab("Qualite")
g3 <- ggplot(df, aes(x = Qualite, y = valuecumul)) + geom_bar(stat = "identity") +
ggtitle("Fréquences cumulées")
g4 <- ggplot(df, aes(x = "", y = freq, fill = Qualite)) + geom_bar(width = 1, stat = "identity") +
coord_polar("y", start = 0)
grid.arrange(g1, g2, g3, g4, ncol = 2)
mean(Data$Alcool)
var(Data$Alcool)
sd(Data$Alcool)
range(Data$Alcool)
min(Data$Alcool)
max(Data$Alcool)
diff(range(Data$Alcool))
median(Data$Alcool)
sort(Data$Alcool)[296:305]
quantile(Data$Alcool)
quantile(Data$Alcool,0.9)
q.Alc <- quantile(x = Data$Alcool, probs=c(.25,.75), names=FALSE)
diff(q.Alc)
L=q.Alc + diff(q.Alc) * c(-1.5,1.5) ; L
# valeur adjacente inférieure :
min(Data$Alcool[Data$Alcool>=L[1]])
# valeur adjacente supérieure :
max(Data$Alcool[Data$Alcool<=L[2]])
summary(Data$Alcool)
g1<-ggplot(Data,aes(x=Alcool))+geom_histogram(bins=15,color="black", fill="white")+
ggtitle("Histo. des effectifs")+ylab("Frequency")+xlab("Alcool")
g2<-ggplot(Data,aes(x=Alcool))+geom_histogram(aes(y=..density..),bins=15,color="black", fill="white")+
ggtitle("Histo. des frequences")+ylab("Density")+xlab("Alcool")
grid.arrange(g1,g2,ncol=2)
ggplot(Data, aes(Alcool)) +
stat_ecdf(geom = "step")+xlab("Variable Alcool")+
ylab("")+ggtitle("Fonction de répartition empirique")+
geom_hline(yintercept=0, linetype="dashed")+geom_hline(yintercept=1, linetype="dashed")
library(reshape2)
ggplot(melt(Data[,-c(1,2)]),aes(x=variable,y=value))+geom_boxplot()
B <- boxplot(Data$SO2lbr,horizontal=TRUE)
attributes(B)
B$stats
median(Data$SO2lbr)
q <- quantile(x = Data$SO2lbr, probs=c(.25,.75), names=FALSE)
q
L=q + diff(q) * c(-1.5,1.5)
min(Data$SO2lbr[Data$SO2lbr>=L[1]])
max(Data$SO2lbr[Data$SO2lbr<=L[2]])
library(knitr)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
opts_knit$set(width=75)
library(corrplot)
library(tidyverse)
library(gridExtra)
library(reshape2)
Data = read.table("wine.txt",header=TRUE)
head(Data)
attributes(Data)
str(Data)
Data$Qualite=as.factor(Data$Qualite)
Data$Type=factor(Data$Type,labels=c("blanc","rouge"))
head(Data)
summary(Data)
levels(Data$Type)
summary(Data$Type)
EffType = as.vector(table(Data$Type))
EffType
Freq = EffType/length(Data$Type)
knitr::kable(data.frame(modalite=levels(Data$Type),Eff=EffType,Freq=Freq), caption = 'Description de la variable Type',booktabs = TRUE,digits=3)
g1<-ggplot(Data, aes(x=Type))+ geom_bar()+ylab("")+ggtitle("Effectifs")
g2<-ggplot(Data, aes(x = Type)) +
geom_bar(aes(y = (..count..)/sum(..count..)))+ylab("")+ggtitle("Frequences")
quan <- as.vector(table(Data$Type))/nrow(Data)
df <- data.frame(group = levels(Data$Type),value = quan)
g3<-ggplot(df, aes(x="", y=value, fill=group))+
geom_bar(width = 1, stat = "identity")+ coord_polar("y", start=0)+ theme(legend.position="bottom")
grid.arrange(g3,g1,g2,ncol=3)
Qualite_rec <- fct_relevel(Data$Qualite, "bad", "medium", "good")
df <- data.frame(Qualite = levels(Qualite_rec), value = table(Qualite_rec),
valuecumul = 100 * cumsum(prop.table(table(Qualite_rec))))
df$Qualite <- fct_relevel(df$Qualite, "bad", "medium", "good")
df <- df %>%
mutate(freq = value.Freq/nrow(Data))
g1 <- ggplot(Data) + geom_bar(aes(x = Qualite_rec)) + ggtitle("Effectifs")+xlab("Qualite")
g2 <- ggplot(Data) + geom_bar(aes(x = Qualite_rec, y = ..prop.., group = 1)) + ggtitle("Frequences")+xlab("Qualite")
g3 <- ggplot(df, aes(x = Qualite, y = valuecumul)) + geom_bar(stat = "identity") +
ggtitle("Fréquences cumulées")
g4 <- ggplot(df, aes(x = "", y = freq, fill = Qualite)) + geom_bar(width = 1, stat = "identity") +
coord_polar("y", start = 0)
grid.arrange(g1, g2, g3, g4, ncol = 2)
mean(Data$Alcool)
var(Data$Alcool)
sd(Data$Alcool)
range(Data$Alcool)
min(Data$Alcool)
max(Data$Alcool)
diff(range(Data$Alcool))
median(Data$Alcool)
sort(Data$Alcool)[296:305]
quantile(Data$Alcool)
quantile(Data$Alcool,0.9)
q.Alc <- quantile(x = Data$Alcool, probs=c(.25,.75), names=FALSE)
diff(q.Alc)
L=q.Alc + diff(q.Alc) * c(-1.5,1.5) ; L
# valeur adjacente inférieure :
min(Data$Alcool[Data$Alcool>=L[1]])
# valeur adjacente supérieure :
max(Data$Alcool[Data$Alcool<=L[2]])
summary(Data$Alcool)
g1<-ggplot(Data,aes(x=Alcool))+geom_histogram(bins=15,color="black", fill="white")+
ggtitle("Histo. des effectifs")+ylab("Frequency")+xlab("Alcool")
g2<-ggplot(Data,aes(x=Alcool))+geom_histogram(aes(y=..density..),bins=15,color="black", fill="white")+
ggtitle("Histo. des frequences")+ylab("Density")+xlab("Alcool")
grid.arrange(g1,g2,ncol=2)
ggplot(Data, aes(Alcool)) +
stat_ecdf(geom = "step")+xlab("Variable Alcool")+
ylab("")+ggtitle("Fonction de répartition empirique")+
geom_hline(yintercept=0, linetype="dashed")+geom_hline(yintercept=1, linetype="dashed")
library(reshape2)
ggplot(melt(Data[,-c(1,2)]),aes(x=variable,y=value))+geom_boxplot()
B <- boxplot(Data$SO2lbr,horizontal=TRUE)
attributes(B)
B$stats
median(Data$SO2lbr)
q <- quantile(x = Data$SO2lbr, probs=c(.25,.75), names=FALSE)
q
L=q + diff(q) * c(-1.5,1.5)
min(Data$SO2lbr[Data$SO2lbr>=L[1]])
max(Data$SO2lbr[Data$SO2lbr<=L[2]])
B$out
Data$SO2lbr[which(Data$SO2lbr<B$stats[1] | Data$SO2lbr>B$stats[5])]
ggplot(Data,aes(x=Alcool,y=Densite))+geom_point()
corrplot(cor(Data[,-c(1:2)]),method="ellipse")
ggplot(Data,aes(x=Alcool,y=Densite))+geom_point()+
geom_smooth(method=lm, se=FALSE)
g1<-ggplot(Data,aes(x=Qualite,y=Alcool))+geom_boxplot()
g2<-ggplot(Data,aes(x=Type,y=Alcool))+geom_boxplot()
grid.arrange(g1,g2,ncol=2)
table.cont = table(Data$Qualite,Data$Type)
table.cont
mosaicplot(table(Data$Qualite,Data$Type))
mosaicplot(table(Data$Type,Data$Qualite))
help rnorm()
help rnorm
help(rnorm)
library(knitr)
## Global options
opts_chunk$set(echo=TRUE,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
class.source="badCode")
#  A COMPLETER POUR REPONDRE A L'EXERCICE
# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE
ma.variance = function(x){
moyenneJeuX = mean(x)
return(sum((x - moyenneJeuX)^2))
}
# Comparation ma.variance et variance implantée :
x = runif(100, 0, 10)
ma.variance(x)
var(x)
#  A COMPLETER POUR REPONDRE A L'EXERCICE
# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE
ma.variance = function(x){
moyenneJeuX = mean(x)
return(mean((x - moyenneJeuX)^2))
}
# Comparation ma.variance et variance implantée :
x = runif(100, 0, 10)
ma.variance(x)
var(x)
#  A COMPLETER POUR REPONDRE A L'EXERCICE
# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE
ma.variance = function(x){
moyenneJeuX = mean(x)
return(mean((x - moyenneJeuX)^2))
}
# Comparation ma.variance et variance implantée :
x = runif(100, 0, 10)
ma.variance(x)
var(x)
#  A COMPLETER POUR REPONDRE A L'EXERCICE
# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE
ma.variance = function(x){
moyenneJeuX = mean(x)
return(mean((x - moyenneJeuX)^2))
}
# Comparation ma.variance et variance implantée :
x = runif(1000, 0, 10)
ma.variance(x)
var(x)
#  A COMPLETER POUR REPONDRE A L'EXERCICE
# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE
ma.variance = function(x){
moyenneJeuX = mean(x)
return(mean((x - moyenneJeuX)^2))
}
# Comparation ma.variance et variance implantée :
x = runif(100, 0, 10)
ma.variance(x)
var(x)
#  A COMPLETER POUR REPONDRE A L'EXERCICE
# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE
# Quesion 1 :
ma.variance = function(x){
moyenneJeuX = mean(x)
return(mean((x - moyenneJeuX)^2))
}
# Comparation ma.variance et variance implantée :
x = runif(100, 0, 10)
ma.variance(x)
var(x)
# Quesion 2 :
fibo = function(n){
res = c(0,1)    # u1 et u2 pour la suite de Fibonacci
if (n>=3) {
for (i in seq(3,n,1)){
res[i] = c[i-2] + c[i-1]
}
}
return(ifelse(is.integer(n) & x >= 1, res[n], "Le paramètre doit être entier naturel strictement positif"))
}
# Test des valeurs de la suite
fibo(1)
fibo(2)
fibo(3)
#  A COMPLETER POUR REPONDRE A L'EXERCICE
# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE
# Quesion 1 :
ma.variance = function(x){
moyenneJeuX = mean(x)
return(mean((x - moyenneJeuX)^2))
}
# Comparation ma.variance et variance implantée :
x = runif(100, 0, 10)
ma.variance(x)
var(x)
# Quesion 2 :
fibo = function(n){
res = c(0,1)    # u1 et u2 pour la suite de Fibonacci
if (n>=3) {
for (i in seq(3,n,1)){
res[i] = c[i-2] + c[i-1]
}
}
return(ifelse(is.integer(n) & x >= 1, res[n], "Le paramètre doit être entier naturel strictement positif"))
}
# Test des valeurs de la suite
fibo(integer(1))
fibo(integer(2))
#  A COMPLETER POUR REPONDRE A L'EXERCICE
# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE
# Quesion 1 :
ma.variance = function(x){
moyenneJeuX = mean(x)
return(mean((x - moyenneJeuX)^2))
}
# Comparation ma.variance et variance implantée :
x = runif(100, 0, 10)
ma.variance(x)
var(x)
# Quesion 2 :
fibo = function(n){
res = c(0,1)    # u1 et u2 pour la suite de Fibonacci
if (n>=3) {
for (i in seq(3,n,1)){
res[i] = c[i-2] + c[i-1]
}
}
else {
NULL
}
return(ifelse(is.integer(n) & x >= 1, res[n], "Le paramètre doit être entier naturel strictement positif"))
}
# Test des valeurs de la suite
fibo(integer(1))
fibo(integer(2))
n=seq(100,10000,100)
mest=NULL
sigma2est=NULL
for (i in 1:length(n)){
x = (rnorm(n[i], mean = 5, sigma2 = 4)      # echantillon à simuler
mest = c(mest, mean(x))    # estimation de m
sigma2est=c(sigma2est, var(x))  # estimation de sigma2
}
n=seq(100,10000,100)
mest=NULL
sigma2est=NULL
for (i in 1:length(n)){
x = (rnorm(n[i], mean = 5, sigma2 = 4))      # echantillon à simuler
mest = c(mest, mean(x))    # estimation de m
sigma2est=c(sigma2est, var(x))  # estimation de sigma2
}
n=seq(100,10000,100)
mest=NULL
sigma2est=NULL
for (i in 1:length(n)){
x = (rnorm(n[i], mean = 5, sigma = 2))      # echantillon à simuler
mest = c(mest, mean(x))    # estimation de m
sigma2est=c(sigma2est, var(x))  # estimation de sigma2
}
n=seq(100,10000,100)
mest=NULL
sigma2est=NULL
for (i in 1:length(n)){
x = (rnorm(n[i], mean = 5, sd = 2))      # echantillon à simuler
mest = c(mest, mean(x))    # estimation de m
sigma2est=c(sigma2est, var(x))  # estimation de sigma2
}
mest
df=data.frame(n=n,mest=mest,sigma2est=sigma2est)
ggplot(df,aes(x=n,y=mest))+
geom_point()+
geom_hline(yintercept=5, color="red")
ggplot(df,aes(x=n,y=sigma2est))+
geom_point()+
geom_hline(yintercept=4, color="red")
# A COMPLETER
int.conf.moy1 <- function(x,niv.conf,sigma2){
alpha = 1-niv.conf
IC = mean(x) + c(-1,1) * qnorm(1-alpha/2) * sqrt(sigma2/length(x))
return(IC)
}
n= c(10,100,1000)     # modifié
niv.conf = c(0.9,0.95,0.975)      # modifié
for (i in 1:length(n)){
for (j in 1:length(niv.conf)){
x= rnorm(n[i], mean = 5, sd = 2)
IC=int.conf.moy1(x, niv.conf[i], sd^2)
print(paste("n= ", n[i],", niv.conf= ",niv.conf[j]," : IC vaut [", round(IC[1],3),",",round(IC[2],3),"], il est de longueur",round(IC[2]-IC[1],3), sep=""))
}
}
# A COMPLETER
int.conf.moy1 <- function(x,niv.conf,sigma2){
alpha = 1-niv.conf
IC = mean(x) + c(-1,1) * qnorm(1-alpha/2) * sqrt(sigma2/length(x))
return(IC)
}
n= c(10,100,1000)     # modifié
niv.conf = c(0.9,0.95,0.975)      # modifié
for (i in 1:length(n)){
for (j in 1:length(niv.conf)){
x= rnorm(n[i], mean = 5, sd = 2)
IC=int.conf.moy1(x, niv.conf[i], sigma2 = 4)
print(paste("n= ", n[i],", niv.conf= ",niv.conf[j]," : IC vaut [", round(IC[1],3),",",round(IC[2],3),"], il est de longueur",round(IC[2]-IC[1],3), sep=""))
}
}
n= c(10,100,1000)     # modifié
niv.conf = c(0.9,0.95,0.975)      # modifié
for (i in 1:length(n)){
for (j in 1:length(niv.conf)){
x= rnorm(n[i], mean = 5, sd = 2)
IC=int.conf.moy1(x, niv.conf[j], sigma2 = 4)
print(paste("n= ", n[i],", niv.conf= ",niv.conf[j]," : IC vaut [", round(IC[1],3),",",round(IC[2],3),"], il est de longueur",round(IC[2]-IC[1],3), sep=""))
}
}
propconf <- function(K,m){
nb.app=0
for (k in 1:K){
x = rnorm(n = 1000, mean = m, sd = 2)
IC=int.conf.moy1(x, niv.conf = 0.95, sigma2 = 4)
nb.app = nb.app + (m>=IC[1]) * (m<=IC[2])
}
return(nb.app/K)
}
propconf <- function(K,m){
nb.app=0
for (k in 1:K){
x = rnorm(n = 1000, mean = m, sd = 2)
IC=int.conf.moy1(x, niv.conf = 0.95, sigma2 = 4)
nb.app = nb.app + (m>=IC[1]) * (m<=IC[2])
}
return(nb.app/K)
}
K = seq(100,1000,100)
m = 5
propconf(K,m)
propconf <- function(K,m){
nb.app=0
for (k in 1:K){
x = rnorm(n = 1000, mean = m, sd = 2)
IC=int.conf.moy1(x, niv.conf = 0.95, sigma2 = 4)
nb.app = nb.app + (m>=IC[1]) * (m<=IC[2])
}
return(nb.app/K)
}
K = seq(100,10000,100)
m = 5
propconf(K,m)
propconf <- function(K,m){
nb.app=0
for (k in 1:K){
x = rnorm(n = 1000, mean = m, sd = 2)
IC=int.conf.moy1(x, niv.conf = 0.95, sigma2 = 4)
nb.app = nb.app + (m>=IC[1]) * (m<=IC[2])
}
return(nb.app/K)
}
K = seq(100,100000,1000)
m = 5
propconf(K,m)
propconf <- function(K,m){
nb.app=0
for (k in 1:K){
x = rnorm(n = 1000, mean = m, sd = 2)
IC=int.conf.moy1(x, niv.conf = 0.95, sigma2 = 4)
nb.app = nb.app + (m>=IC[1]) * (m<=IC[2])
}
return(nb.app/K)
}
K = seq(100,1000,100)
m = 5
propconf(K,m)
propconf <- function(K,m){
nb.app=0
for (k in 1:K){
x = rnorm(n = 1000, mean = m, sd = 2)
IC=int.conf.moy1(x, niv.conf = 0.95, sigma2 = 4)
nb.app = nb.app + (m>=IC[1]) * (m<=IC[2])
}
return(nb.app/K)
}
K = seq(100,1000,100)
m = 5
propconf(K,m)
boxplot(propconf(K,m))
# A COMPLETER
int.conf.moy2 <- function(x,niv.conf){
alpha = 1-niv.conf
S2 =  var(x)   # estimateur de la variance
IC = mean(x) + c(-1,1) * qt(1-alpha/2,length(x)-1) * sqrt(S2/length(x))
return(IC)
}
n= c(10, 100, 1000)
niv.conf = c(0.9,0.95,0.975)
for (i in 1:length(n)){
for (j in 1:length(niv.conf)){
x= rnorm(n[i], mean = 5, sd = 2)
IC=int.conf.moy2(x, niv.conf[j])
print(paste("n= ", n[i],", niv.conf= ",niv.conf[j]," : IC vaut [", round(IC[1],3),",",round(IC[2],3),"], il est de longueur",round(IC[2]-IC[1],3), sep=""))
}
}
n= c(10, 100, 1000)
niv.conf = c(0.9,0.95,0.975)
for (i in 1:length(n)){
for (j in 1:length(niv.conf)){
x= rnorm(n[i], mean = 5, sd = 2)
IC=int.conf.moy2(x, niv.conf[j])
print(paste("n= ", n[i],", niv.conf= ",niv.conf[j]," : IC vaut [", round(IC[1],3),",",round(IC[2],3),"], il est de longueur",round(IC[2]-IC[1],3), sep=""))
}
}
x = rnorm(n = 1000, mean = 5, sd =2) # Echantillon simulé
int.conf.moy1(x,niv.conf=0.95,sigma2= 4)
int.conf.moy2(x,niv.conf=0.95)
t.test(x,conf.level=0.95)
