Data_mlg$lib_epci = as.factor(Data_mlg$lib_epci)
Data_mlg$annee_inv = as.factor(Data_mlg$annee_inv)
Data_mlg$TypeEPCI = as.factor(Data_mlg$TypeEPCI)
# On prend les données quantitatives log
Data_mlg$nh3_kg = log(Data_mlg$nh3_kg)
Data_mlg$n2o_t = log(Data_mlg$n2o_t)
# Je retire les outliers
Data_mlg <- subset(Data_mlg, lib_epci != "Toulouse Métropole") #, "CC Pays de Nay"))
Data_mlg <- subset(Data_mlg, lib_epci != "CC Pays de Nay")
summary(Data_mlg)
# Je garde les variables qui m'intéresse
Data_mlg <- Data_mlg[c(3,10,12,14,15)]
summary(Data_mlg)
# Je crée une nouvelle variable qualitative (celle qui traduit méthane > 1000t)
Data_mlg$dep_met_1000 <- as.factor(as.numeric(Data_mlg$ch4_t>1000))
summary(Data_mlg)
# Je retire la variable quantitative ch4_t
Data_mlg <- Data_mlg[c(1,2,4,5,6)]
summary(Data_mlg)
sum(Data_mlg$dep_met_1000)
library(corrplot)
library(tidyverse)
library(gridExtra)
library(reshape2)
library(ggplot2)
library(FactoMineR)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(corrplot)
library(tidyverse)
library(gridExtra)
library(reshape2)
library(ggplot2)
library(FactoMineR)
library(bestglm)
# TODO : à remettre en commun
# Ici je refais la sélection des variables (je ne leur applique ni log ni scale)
Data_mlg = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
Data_mlg$code_epci = as.factor(Data_mlg$code_epci)
Data_mlg$lib_epci = as.factor(Data_mlg$lib_epci)
Data_mlg$annee_inv = as.factor(Data_mlg$annee_inv)
Data_mlg$TypeEPCI = as.factor(Data_mlg$TypeEPCI)
# On prend les données quantitatives log
Data_mlg$nh3_kg = log(Data_mlg$nh3_kg)
Data_mlg$n2o_t = log(Data_mlg$n2o_t)
# Je retire les outliers
Data_mlg <- subset(Data_mlg, lib_epci != "Toulouse Métropole") #, "CC Pays de Nay"))
Data_mlg <- subset(Data_mlg, lib_epci != "CC Pays de Nay")
summary(Data_mlg)
# Je garde les variables qui m'intéresse
Data_mlg <- Data_mlg[c(3,10,12,14,15)]
summary(Data_mlg)
# Je crée une nouvelle variable qualitative (celle qui traduit méthane > 1000t)
Data_mlg$dep_met_1000 <- as.factor(as.numeric(Data_mlg$ch4_t>1000))
summary(Data_mlg)
# Je retire la variable quantitative ch4_t
Data_mlg <- Data_mlg[c(1,2,4,5,6)]
summary(Data_mlg)
sum(Data_mlg$dep_met_1000)
modelcompletinter = glm(dep_met_1000~(.)^2 ,data=Data_mlg, family=binomial(link = "logit"))
summary(modelcompletinter)
# Quelque chose semble ne pas fonctionner dans les step.backward
step.backward = step(modelcompletinter) # AIC
step.backward = step(modelcompletinter, direction="backward",k=log(nrow(Data_mlg))) # BIC
# Modèle 2
modelinterred = glm(dep_met_1000~annee_inv + nh3_kg + n2o_t + TypeEPCI + annee_inv:nh3_kg +
annee_inv:n2o_t + nh3_kg:n2o_t + nh3_kg:TypeEPCI + n2o_t:TypeEPCI ,data=Data_mlg, family=binomial(link = "logit"))
summary(modelinterred)
anova(modelinterred, modelcompletinter, test="Chisq")
# Modèle 3
modelcompletadd = glm(dep_met_1000~. ,data=Data_mlg, family=binomial(link = "logit"))
summary(modelcompletadd)
anova(modelcompletadd, modelcompletinter, test="Chisq")
library(bestglm)
# TODO : à remettre en commun
# Ici je refais la sélection des variables (je ne leur applique ni log ni scale)
Data_mlg = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
Data_mlg$code_epci = as.factor(Data_mlg$code_epci)
Data_mlg$lib_epci = as.factor(Data_mlg$lib_epci)
Data_mlg$annee_inv = as.factor(Data_mlg$annee_inv)
Data_mlg$TypeEPCI = as.factor(Data_mlg$TypeEPCI)
# On prend les données quantitatives log
Data_mlg$nh3_kg = log(Data_mlg$nh3_kg)
Data_mlg$n2o_t = log(Data_mlg$n2o_t)
# Je retire les outliers
Data_mlg <- subset(Data_mlg, lib_epci != "Toulouse Métropole") #, "CC Pays de Nay"))
Data_mlg <- subset(Data_mlg, lib_epci != "CC Pays de Nay")
summary(Data_mlg)
# Je garde les variables qui m'intéresse
Data_mlg <- Data_mlg[c(3,10,12,14,15)]
summary(Data_mlg)
# Je crée une nouvelle variable qualitative (celle qui traduit méthane > 1000t)
Data_mlg$dep_met_1000 <- as.factor(as.numeric(Data_mlg$ch4_t>1000))
summary(Data_mlg)
# Je retire la variable quantitative ch4_t
Data_mlg <- Data_mlg[c(1,2,4,5,6)]
summary(Data_mlg)
head(Data_mlg)
summary(Data_mlg)
modelcompletinter = glm(dep_met_1000~(.)^2 ,data=Data_mlg, family=binomial(link = "logit"))
summary(modelcompletinter)
# Quelque chose semble ne pas fonctionner dans les step.backward
step.backward = step(modelcompletinter) # AIC
step.backward = step(modelcompletinter, direction="backward",k=log(nrow(Data_mlg))) # BIC
# Quelque chose semble ne pas fonctionner dans les step.backward
step.backward = step(modelcompletinter) # AIC
step.backward = step(modelcompletinter, direction="backward",k=log(nrow(Data_mlg))) # BIC
knitr::opts_chunk$set(echo = TRUE)
library(bestglm)
# TODO : à remettre en commun
# Ici je refais la sélection des variables (je ne leur applique ni log ni scale)
Data_mlg = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
Data_mlg$code_epci = as.factor(Data_mlg$code_epci)
Data_mlg$lib_epci = as.factor(Data_mlg$lib_epci)
Data_mlg$annee_inv = as.factor(Data_mlg$annee_inv)
Data_mlg$TypeEPCI = as.factor(Data_mlg$TypeEPCI)
# On prend les données quantitatives log
Data_mlg$nh3_kg = log(Data_mlg$nh3_kg)
Data_mlg$n2o_t = log(Data_mlg$n2o_t)
# Je retire les outliers
Data_mlg <- subset(Data_mlg, lib_epci != "Toulouse Métropole") #, "CC Pays de Nay"))
Data_mlg <- subset(Data_mlg, lib_epci != "CC Pays de Nay")
summary(Data_mlg)
# Je garde les variables qui m'intéresse
Data_mlg <- Data_mlg[c(3,10,12,14,15)]
summary(Data_mlg)
# Je crée une nouvelle variable qualitative (celle qui traduit méthane > 1000t)
Data_mlg$dep_met_1000 <- as.factor(as.numeric(Data_mlg$ch4_t>1000))
summary(Data_mlg)
# Je retire la variable quantitative ch4_t
Data_mlg <- Data_mlg[c(1,2,4,5,6)]
summary(Data_mlg)
head(Data_mlg)
pseudoR2 = 1 - modelcompletinter$deviance/modelcompletinter$null.deviance
pseudoR2
# Les bestglm ne fonctionnent pas
#bestglm(Data_mlg,family=binomial,IC="AIC")
#bestglm(Data_mlg,family=binomial,IC="BIC")
# Quelque chose semble ne pas fonctionner dans les step.backward
step.backward = step(modelcompletinter) # AIC
step.backward = step(modelcompletinter, direction="backward",k=log(nrow(Data_mlg))) # BIC
# Quelque chose semble ne pas fonctionner dans les step.backward
step.backward = step(modelcompletinter) # AIC
step.backward = step(modelcompletinter, direction="backward",k=log(nrow(Data_mlg))) # BIC
# Modèle 2
model2 = glm(dep_met_1000~annee_inv + nh3_kg + n2o_t + TypeEPCI + annee_inv:nh3_kg +
annee_inv:n2o_t + nh3_kg:n2o_t + nh3_kg:TypeEPCI + n2o_t:TypeEPCI ,data=Data_mlg, family=binomial(link = "logit"))
summary(model2)
anova(model2, modelcompletinter, test="Chisq")
pseudoR2 = 1 - modelinterred$deviance/modelinterred$null.deviance
pseudoR2
# Modèle 3
model3 = glm(dep_met_1000 ~ nh3_kg + n2o_t + TypeEPCI + nh3_kg:n2o_t,data=Data_mlg, family=binomial(link = "logit"))
summary(model3)
anova(model3, modelcompletinter, test="Chisq")
# Modèle 2
model2 = glm(dep_met_1000~annee_inv + nh3_kg + n2o_t + TypeEPCI + annee_inv:nh3_kg +
annee_inv:n2o_t + nh3_kg:n2o_t + nh3_kg:TypeEPCI + n2o_t:TypeEPCI ,data=Data_mlg, family=binomial(link = "logit"))
summary(model2)
$$
library(bestglm)
# TODO : à remettre en commun
# Ici je refais la sélection des variables (je ne leur applique ni log ni scale)
Data_mlg = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
Data_mlg$code_epci = as.factor(Data_mlg$code_epci)
Data_mlg$lib_epci = as.factor(Data_mlg$lib_epci)
Data_mlg$annee_inv = as.factor(Data_mlg$annee_inv)
Data_mlg$TypeEPCI = as.factor(Data_mlg$TypeEPCI)
# On prend les données quantitatives log
Data_mlg$nh3_kg = log(Data_mlg$nh3_kg)
Data_mlg$n2o_t = log(Data_mlg$n2o_t)
# Je retire les outliers
Data_mlg <- subset(Data_mlg, lib_epci != "Toulouse Métropole") #, "CC Pays de Nay"))
Data_mlg <- subset(Data_mlg, lib_epci != "CC Pays de Nay")
summary(Data_mlg)
# Je garde les variables qui m'intéresse
Data_mlg <- Data_mlg[c(3,10,12,14,15)]
summary(Data_mlg)
# Je crée une nouvelle variable qualitative (celle qui traduit méthane > 1000t)
Data_mlg$dep_met_1000 <- as.factor(as.numeric(Data_mlg$ch4_t>1000))
summary(Data_mlg)
# Je retire la variable quantitative ch4_t
Data_mlg <- Data_mlg[c(1,2,4,5,6)]
summary(Data_mlg)
head(Data_mlg)
modelcompletinter = glm(dep_met_1000~(.)^2, data=Data_mlg, family=binomial(link = "logit"))
summary(modelcompletinter)
pseudoR2 = 1 - modelcompletinter$deviance/modelcompletinter$null.deviance
pseudoR2
# Les bestglm ne fonctionnent pas
#bestglm(Data_mlg,family=binomial,IC="AIC")
#bestglm(Data_mlg,family=binomial,IC="BIC")
# Quelque chose semble ne pas fonctionner dans les step.backward
step.backward = step(modelcompletinter) # AIC
step.backward = step(modelcompletinter, direction="backward",k=log(nrow(Data_mlg))) # BIC
# Quelque chose semble ne pas fonctionner dans les step.backward
step.backward = step(modelcompletinter) # AIC
step.backward = step(modelcompletinter, direction="backward",k=log(nrow(Data_mlg))) # BIC
knitr::opts_chunk$set(echo = TRUE)
library(corrplot)
#library(tidyverse)
library(gridExtra)
library(reshape2)
library(ggplot2)
library(FactoMineR)
Data = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
head(Data)
Data$TypeEPCI=as.factor(Data$TypeEPCI)
Data$annee_inv=as.factor(Data$annee_inv)
Data$nomdepart=as.factor(Data$nomdepart)
Data$lib_epci=as.factor(Data$lib_epci)
Data$Ardèche = as.factor(Data$Ardèche)
Data$Ariège = as.factor(Data$Ariège)
Data$Aude = as.factor(Data$Aude)
Data$Aveyron = as.factor(Data$Aveyron)
Data$Gard = as.factor(Data$Gard)
Data$Haute.Garonne = as.factor(Data$Haute.Garonne)
Data$Gers = as.factor(Data$Gers)
Data$Hérault = as.factor(Data$Hérault)
Data$Landes = as.factor(Data$Landes)
Data$Lot = as.factor(Data$Lot)
Data$Lot.et.Garonne = as.factor(Data$Lot.et.Garonne)
Data$Lozère = as.factor(Data$Lozère)
Data$Pyrénées.Atlantiques = as.factor(Data$Pyrénées.Atlantiques)
Data$Hautes.Pyrénées = as.factor(Data$Hautes.Pyrénées)
Data$Pyrénées.Orientales = as.factor(Data$Pyrénées.Orientales)
Data$Tarn = as.factor(Data$Tarn)
Data$Tarn.et.Garonne = as.factor(Data$Tarn.et.Garonne)
Data$Vaucluse = as.factor(Data$Vaucluse)
summary(Data)
str(Data)
ggplot(melt(Data[4:14]),aes(x=variable,y=value))+geom_boxplot()
Datalog = Data
Datalog[,4:14] = log(Datalog[,4:14])
ggplot(melt(Datalog[,4:14]),aes(x=variable,y=value))+geom_boxplot()
#ggplot(Datalog) + # plot fonction densité
# aes(x = nox_kg) +
#  geom_density() +
# ggtitle("Nombre") +
#xlab("Heures") +
#ylab("Densité")
ggplot(Datalog) +
aes(x = nox_kg) +
stat_ecdf() +
ylab(" ") +
ggtitle("Fonction de répartition de la concentration d'oxyde d'azote en kg")
ggplot(Datalog) +
aes(x = so2_kg) +
stat_ecdf() +
ylab(" ") +
ggtitle("Fonction de répartition de la concentration d'oxyde de soufre en kg")
ggplot(Datalog) +
aes(x = co_kg) +
stat_ecdf() +
ylab(" ") +
ggtitle("Fonction de répartition de la concentration de monoxyde de carbone")
ggplot(Datalog) +
aes(x = pm25_kg) +
stat_ecdf() +
ylab(" ") +
ggtitle("Fonction de répartition de la concentration d'oxyde d'azote en kg")
ggplot(Datalog) +
aes(x = pm25_kg) +
stat_ecdf() +
ylab(" ") +
ggtitle("Fonction de répartition de la concentration d'oxyde d'azote en kg")
ggplot(Datalog) +
aes(x = pm25_kg) +
stat_ecdf() +
ylab(" ") +
ggtitle("Fonction de répartition de la concentration d'oxyde d'azote en kg")
ggplot(Data) + aes(annee_inv) + geom_bar()+ ggtitle("Répartition du nombre de mesure en fonction des années")
ggplot(Data) + aes(TypeEPCI) + geom_bar()+ ggtitle("Répartition du nombre de mesure en fonction du Type EPCI (avant)")
Datalog_ = Datalog
levels(Datalog_[c(3,10,12, 14,15)]$TypeEPCI) <- c("CA/CU/Métropole", "CC", "CA/CU/Métropole", "CA/CU/Métropole")
ggplot(Datalog_) + aes(TypeEPCI) + geom_bar()+ ggtitle("Répartition du nombre de mesure en fonction du Type EPCI (après)")
corrplot(cor(Datalog_[4:14]), method="ellipse")
boxplot(Datalog$pm10_kg~Datalog$TypeEPCI)
library(mclust)
library(mclust)
library(cluster)
library(factoextra)
library(FactoMineR)
library(ppclust)
library(reticulate)
library(ggplot2)
library(reshape)
library(corrplot)
library(gridExtra)
library(circlize)
library(viridis)
library(reshape2)
library(klaR)
ACPpolluants <- PCA(Datalog_[,1:16], scale.unit = TRUE, ncp = 11, quali.sup = c(1,2,3,15,16), graph = FALSE)
ggplot(data.frame(ACPpolluants$eig)) + aes(x = 1:11, y =ACPpolluants$eig[,"percentage of variance"]) + geom_col() + xlab("Dimension") + ylab("%") + ggtitle("Pourcentage de variance par dimension")
ggplot(data.frame(ACPpolluants$eig)) + aes(x = 1:11, y =ACPpolluants$eig[,"cumulative percentage of variance"]) + geom_col() + xlab("Dimension") + ylab("%") + ggtitle("Pourcentage de variance cumulée")
fviz_pca_var(ACPpolluants,axes =c(1,2))
fviz_pca_ind(ACPpolluants,col.ind=as.factor(Datalog_$TypeEPCI),geom = c("point"),axes=c(1,2))
#fviz_pca_ind(ACPpolluants,col.ind=as.factor(Datalog$annee_inv),geom = c("point"),axes=c(1,2)) utile de mettre celui avec les années ?
fviz_pca_ind(ACPpolluants,col.ind=as.factor(Datalog$TypeEPCI),geom = c("point"),axes=c(1,2))
Data_final <- subset(Datalog_, lib_epci != "Toulouse Métropole")
Data_final <- subset(Data_final, lib_epci != "CC Pays de Nay")
ACPpolluants_ <- PCA(Data_final[1:16], scale.unit = TRUE, ncp = 3, quali.sup = c(1,2,3,15,16), graph = FALSE)  # Utilisation de scale.unit = TRUE pour    (TODO : faut qu'on supprime le commentaire ou qu'on le complète)
fviz_pca_var(ACPpolluants_,axes =c(1,2))
fviz_pca_ind(ACPpolluants_,col.ind=as.factor(Data_final$TypeEPCI),geom = c("point"),axes=c(1,2))
reskmeans<-kmeans((Data_final[,4:14]),centers=5)
table(reskmeans$cluster)
fviz_cluster(reskmeans,data=Data_final[,4:14],ellipse.type="norm",labelsize=8,geom=c("point"), axes = c(1,2))+ggtitle("")
reskmeans<-kmeans((Datalog[,4:14]),centers=7)
table(reskmeans$cluster)
fviz_cluster(reskmeans,data=Datalog[,4:14],ellipse.type="norm",labelsize=8,geom=c("point"), axes = c(1,2))+ggtitle("")
# A completer
Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(Data_final),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
resaux<-kmeans(Data_final[,4:14],centers=k)
reskmeanscl[,k-1]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss)
}
df<-data.frame(K=2:15,Iintra=Iintra)
ggplot(df,aes(x=K,y=Iintra))+geom_line()+geom_point()+xlab("Nombre de classes")+ylab("Inertie intraclasse")
# A completer
Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(Datalog),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
resaux<-kmeans(Datalog[,4:14],centers=k)
reskmeanscl[,k-1]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss)
}
df<-data.frame(K=2:15,Iintra=Iintra)
ggplot(df,aes(x=K,y=Iintra))+geom_line()+geom_point()+xlab("Nombre de classes")+ylab("Inertie intraclasse")
complet<-lm(ch4_t ~ .^2 ,data=Datalog_[c(3,10,12, 14,15)])
summary(complet)
mod_si<-lm(ch4_t ~ . ,data=Datalog_[c(3,10,12, 14,15)])
summary(mod_si)
anova(mod_si,complet)
mod_si<-lm(ch4_t ~ . ,data=Datalog_[c(3,10,12, 14,15)])
summary(mod_si)
anova(mod_si,complet)
stepAIC(complet,trace=F,direction="backward")
stepAIC(complet,trace=F,direction="backward",k=log(nrow(Datalog_[c(3,10,12, 14,15)])))
M3 = lm(ch4_t ~ annee_inv + nh3_kg + n2o_t + TypeEPCI +
nh3_kg:n2o_t + nh3_kg:TypeEPCI + n2o_t:TypeEPCI, data = Datalog_[c(3,
10, 12, 14, 15)])
anova(M3, complet)
anova(lm(formula = ch4_t ~ annee_inv + nh3_kg + n2o_t + TypeEPCI +
nh3_kg:TypeEPCI + n2o_t:TypeEPCI, data = Datalog_[c(3,
10, 12, 14, 15)]), complet)
library(bestglm)
#library(bestglm)
# TODO : voir si la libraire est vraiment nécessaire
# TODO : à remettre en commun
# Ici je refais la sélection des variables (je ne leur applique ni log ni scale)
Data_mlg = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
Data_mlg$code_epci = as.factor(Data_mlg$code_epci)
Data_mlg$lib_epci = as.factor(Data_mlg$lib_epci)
Data_mlg$annee_inv = as.factor(Data_mlg$annee_inv)
Data_mlg$TypeEPCI = as.factor(Data_mlg$TypeEPCI)
# On prend les données quantitatives log
Data_mlg$nh3_kg = log(Data_mlg$nh3_kg)
Data_mlg$n2o_t = log(Data_mlg$n2o_t)
# Je retire les outliers
Data_mlg <- subset(Data_mlg, lib_epci != "Toulouse Métropole") #, "CC Pays de Nay"))
Data_mlg <- subset(Data_mlg, lib_epci != "CC Pays de Nay")
summary(Data_mlg)
# Je garde les variables qui m'intéressent
Data_mlg <- Data_mlg[c(3,10,12,14,15)]
summary(Data_mlg)
# Je crée une nouvelle variable qualitative (celle qui traduit méthane > 1000t)
Data_mlg$dep_met_1000 <- as.factor(as.numeric(Data_mlg$ch4_t>1000))
summary(Data_mlg)
# Je retire la variable quantitative ch4_t
Data_mlg <- Data_mlg[c(1,2,4,5,6)]
summary(Data_mlg)
head(Data_mlg)
modelcompletinter = glm(dep_met_1000~(.)^2, data=Data_mlg, family=binomial(link = "logit"))
summary(modelcompletinter)
pseudoR2 = 1 - modelcompletinter$deviance/modelcompletinter$null.deviance
pseudoR2
# Les bestglm ne fonctionnent pas
#bestglm(Data_mlg,family=binomial,IC="AIC")
#bestglm(Data_mlg,family=binomial,IC="BIC")
# Quelque chose semble ne pas fonctionner dans les step.backward
step.backward = step(modelcompletinter) # AIC
step.backward = step(modelcompletinter, direction="backward",k=log(nrow(Data_mlg))) # BIC
# Modèle 2
model2 = glm(dep_met_1000~annee_inv + nh3_kg + n2o_t + TypeEPCI + annee_inv:nh3_kg +
annee_inv:n2o_t + nh3_kg:n2o_t + nh3_kg:TypeEPCI + n2o_t:TypeEPCI ,data=Data_mlg, family=binomial(link = "logit"))
summary(model2)
anova(model2, modelcompletinter, test="Chisq")
pseudoR2 = 1 - modelinterred$deviance/modelinterred$null.deviance
pseudoR2
# Modèle 3
model3 = glm(dep_met_1000 ~ nh3_kg + n2o_t + TypeEPCI + nh3_kg:n2o_t,data=Data_mlg, family=binomial(link = "logit"))
summary(model3)
anova(model3, modelcompletinter, test="Chisq")
# Quelque chose semble ne pas fonctionner dans les step.backward
step.backward = step(modelcompletinter) # AIC
step.backward = step(modelcompletinter, direction="backward",k=log(nrow(Data_mlg))) # BIC
# Je garde les variables qui m'intéressent
Data_mlg <- Data_mlg[c(3,10,12,14,15)]
#library(bestglm)
# TODO : voir si la libraire est vraiment nécessaire
# TODO : à remettre en commun
# Ici je refais la sélection des variables (je ne leur applique ni log ni scale)
Data_mlg = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
Data_mlg$code_epci = as.factor(Data_mlg$code_epci)
Data_mlg$lib_epci = as.factor(Data_mlg$lib_epci)
Data_mlg$annee_inv = as.factor(Data_mlg$annee_inv)
Data_mlg$TypeEPCI = as.factor(Data_mlg$TypeEPCI)
# On prend les données quantitatives log
Data_mlg$nh3_kg = log(Data_mlg$nh3_kg)
Data_mlg$n2o_t = log(Data_mlg$n2o_t)
# Je retire les outliers
Data_mlg <- subset(Data_mlg, lib_epci != "Toulouse Métropole") #, "CC Pays de Nay"))
Data_mlg <- subset(Data_mlg, lib_epci != "CC Pays de Nay")
summary(Data_mlg)
# Je garde les variables qui m'intéressent
Data_mlg <- Data_mlg[c(3,10,12,14,15)]
summary(Data_mlg)
summary(Data_mlg)
summary(Datalog)
summary(Data_mlg)
summary(Datalog)
Datalog[c(3,10,12,14,15)]
summary(Datalog[c(3,10,12,14,15)])
summary(Datalog)
head(Datalog)
summary(Datalog[c(3,10,14,15,36)])
summary(Datalog_[c(3,10,14,15,36)])
head(Datafinal)
head(Data_final)
summary(Datalog[c(3,10,14,15,36)])
summary(Data_final[c(3,10,14,15,36)])
summary(Data_final[c(3,10,12,14,15))
summary(Data_final[c(3,10,12,14,15)])
# Tentative de mise en correspondance des codes
summary(Data_final[c(3,10,12,14,15)])
Data_mlg = Data_final[c(3,10,12,14,15)]
# Je crée une nouvelle variable qualitative (celle qui traduit méthane > 1000t)
Data_mlg$dep_met_1000 <- as.factor(as.numeric(Data_mlg$ch4_t>log(1000)))
summary(Data_mlg)
# Je retire la variable quantitative ch4_t
Data_mlg <- Data_mlg[c(1,2,4,5,6)]
summary(Data_mlg)
head(Data_mlg)
#library(bestglm)
# TODO : voir si la libraire est vraiment nécessaire
# TODO : à remettre en commun
# Ici je refais la sélection des variables (je ne leur applique ni log ni scale)
Data_mlg = read.csv("Data-projetmodIA-2324.csv", header = TRUE)
Data_mlg$code_epci = as.factor(Data_mlg$code_epci)
Data_mlg$lib_epci = as.factor(Data_mlg$lib_epci)
Data_mlg$annee_inv = as.factor(Data_mlg$annee_inv)
Data_mlg$TypeEPCI = as.factor(Data_mlg$TypeEPCI)
# On prend les données quantitatives log
Data_mlg$nh3_kg = log(Data_mlg$nh3_kg)
Data_mlg$n2o_t = log(Data_mlg$n2o_t)
# Je retire les outliers
Data_mlg <- subset(Data_mlg, lib_epci != "Toulouse Métropole") #, "CC Pays de Nay"))
Data_mlg <- subset(Data_mlg, lib_epci != "CC Pays de Nay")
summary(Data_mlg)
# Je garde les variables qui m'intéressent
Data_mlg <- Data_mlg[c(3,10,12,14,15)]
summary(Data_mlg)
# Je crée une nouvelle variable qualitative (celle qui traduit méthane > 1000t)
Data_mlg$dep_met_1000 <- as.factor(as.numeric(Data_mlg$ch4_t>1000))
summary(Data_mlg)
# Je retire la variable quantitative ch4_t
Data_mlg <- Data_mlg[c(1,2,4,5,6)]
summary(Data_mlg)
head(Data_mlg)
#library(bestglm)
# TODO : voir si la libraire est vraiment nécessaire
Data_mlg = Data_final[c(3,10,12,14,15)]
# Je crée une nouvelle variable qualitative (celle qui traduit méthane > 1000t)
Data_mlg$dep_met_1000 <- as.factor(as.numeric(Data_mlg$ch4_t>log(1000)))
summary(Data_mlg)
# Je retire la variable quantitative ch4_t
Data_mlg <- Data_mlg[c(1,2,4,5,6)]
summary(Data_mlg)
head(Data_mlg)
modelcompletinter = glm(dep_met_1000~(.)^2, data=Data_mlg, family=binomial(link = "logit"))
summary(modelcompletinter)
pseudoR2 = 1 - modelcompletinter$deviance/modelcompletinter$null.deviance
pseudoR2
# Les bestglm ne fonctionnent pas
#bestglm(Data_mlg,family=binomial,IC="AIC")
#bestglm(Data_mlg,family=binomial,IC="BIC")
# Quelque chose semble ne pas fonctionner dans les step.backward
step.backward = step(modelcompletinter) # AIC
step.backward = step(modelcompletinter, direction="backward",k=log(nrow(Data_mlg))) # BIC
# Modèle 2
model2 = glm(dep_met_1000~annee_inv + nh3_kg + n2o_t + TypeEPCI + annee_inv:nh3_kg +
annee_inv:n2o_t + nh3_kg:n2o_t + nh3_kg:TypeEPCI + n2o_t:TypeEPCI ,data=Data_mlg, family=binomial(link = "logit"))
summary(model2)
anova(model2, modelcompletinter, test="Chisq")
pseudoR2 = 1 - modelinterred$deviance/modelinterred$null.deviance
pseudoR2
# Modèle 2
model2 = glm(dep_met_1000~annee_inv + nh3_kg + n2o_t + TypeEPCI + annee_inv:nh3_kg +
annee_inv:n2o_t + nh3_kg:n2o_t + nh3_kg:TypeEPCI + n2o_t:TypeEPCI ,data=Data_mlg, family=binomial(link = "logit"))
summary(model2)
anova(model2, modelcompletinter, test="Chisq")
pseudoR2 = 1 - modelinterred$deviance/modelinterred$null.deviance
pseudoR2
# Modèle 3
model3 = glm(dep_met_1000 ~ nh3_kg + n2o_t + TypeEPCI + nh3_kg:n2o_t,data=Data_mlg, family=binomial(link = "logit"))
summary(model3)
anova(model3, modelcompletinter, test="Chisq")
